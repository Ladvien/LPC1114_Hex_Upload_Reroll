//LPC1114 Reset program.  Meant to come before using lpc21isp.  Should allow for 
//popular FTDI breakouts, like Sparkfun's, to be used as a serial programmer for 
//the LPC1114.  Shooting for no manual reset.

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h> 
#include <windows.h>
#include <windef.h>
#include <winnt.h>
#include <winbase.h>
#include <string.h>
#include <math.h>
#include <stdbool.h>
#include "ftd2xx.h"

/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
A. Preparing the data.
1. Hex file accessed. (DONE) I noticed the FTDI chip needs to be using XON/XOFF, I assume I can use FTDI’s library to enable this functionality?
2. Hex file converted to string. Need to store hex data indexed by address.  And, I need to create a checksum to coordinate with the UUE string.  
As I understand it, the checksum is used by the LPC boot loader to ensure the UUE data uploaded is correct.  From what I read, the checksum is 
generated by adding the data bytes together.  Data is not delivered to the LPC in greater than 45 bytes at a time.  Therefore, the checksum 
should be the sum of every 45 bytes?
3. Hex string encoded into a UUE string. I need to divide UUE data into strings of 61 characters, which gives 45 bytes of data.
 
B. LPC-HOST Handshake
1. HOST Send: ‘?’
2. LPC auto-baud measures the data.  The host UART should be set to 8, 1, N.
3. LPC Responds: “Synchronized<CR><LF>”
4. Host should respond: “Synchronized<CR><LF>”
5. LPC Looks at the characters to verify synchronization.
6. LPC Responds: “OK<CR><LF>”
7. Host send crystal frequency in kHz: “12500<CR><LF>”
8. LPC Responds: “OK<CR><LF>”
 
C. Host Writes to LPC
1. Host sends Unlock command: “U 23130<CR><LF>”
2.  Host sends: “W <RAM Address in Decimal> 61<CR><LF>”
3. Host sends UUE line to RAM. Host sends: 61 characters of UUE
4. Host sends respective checksum.
5. If checksum matches, LPC responds: “OK<CR><LF>”
6. If checksum doesn’t match, LPC responds: “RESEND<CR><LF>.” The host should repeat steps 11 & 12.
7. ....we fill up so much of the RAM....
8. Host sends: “P 0 0<CR><LF>.”  The prepares the Flash sector 0 for writing.
9. Host sends: “C <RAM Address in Decimal> 512 0<CR><LF>.”  This should copy two pages of RAM data to Flash at sector 0.  
The smallest amount of data we may write to Flash is 256 bytes (one page).
10. Repeat 1-9 until all data is written to the LPC’s Flash memory.

*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////// Forward Declaration ////////////////////////////////////////////////////////////

// Output files, for debugging purposes.
void writeUUEDataTofile(unsigned char UUE_Encoded_String[], int hexDataCharCount);
void writeHexDataTofile(unsigned char fileData_Hex_String[], int hexDataCharCount, unsigned char byteCount[], int hexFileLineCount);

// FTDI
static FILE *open_file ( char *file, char *mode );
int fileSizer();
unsigned char rx(bool parse, bool printOrNot);
unsigned char parserx();
char txString(char string[], int txString_size, bool printOrNot, int frequency_of_tx_char);
int FTDI_State_Machine(int state, int FT_Attempts);
unsigned char get_LPC_Info(bool print);

// LPC handling
unsigned char set_ISP_mode(int print);

// Data Handling
struct hexFile hexFileToCharArray();
int readByte();
void clearSpecChar();
int Hex2Ascii(unsigned char hexValue);
int Hex2Int(unsigned char c);
static unsigned char Ascii2Hex(unsigned char c);
struct UUE_Data UUencode();
void clearBuffers();

void setTextRed();
void setTextGreen();
void setColor(int ForgC, int BackC);
void clearConsole();
void copy_string(char *target, char *source);
void startScreen();
void OK();
void Failed();
void check_HM_10();
void wake_devices();

//////////////////// Variables and Defines ////////////////////////////////////////////////////////

//#define PIN_TX  0x01  /* Orange wire on FTDI cable */
//#define PIX_RX  0x02  /* Yellow */
//#define PIN_RTS 0x04  /* Green */
#define PIN_CTS 0x08  /* Brown */
#define PIN_DTR 0x10
//#define PIN_DSR 0x20
//#define PIN_DCD 0x40
//#define PIN_RI  0x80

	// HM-11-A sends "AT+PIO30"
	// The HM-11-B PIO3 will go low, which sets the LPC1114 ISP MODE to LOW.  
	// HM-11-A sends "AT+PIO20"
	// Then, the HM-11-B PIO2 goes LOW for ~5uS.  This will reset the LPC.
	// As the LPC comes back up it checks the ISP MODE pin and sees it LOW.
	// HM-11-A sends "AT+PIO31" waits ~100mS then sends "AT+PIO21"
	// The HM-11-B PIO3 and PIO2 will go HIGH.
	// The LPC enters ISP mode.
	// The HM-11 PIO2 & PIO3 go HIGH.
	// The program is uploaded to the LPC.
	// HM-11-A sends "AT+PIO20"
	// HM-11-B PIO2 goes LOW, resetting the LPC.
	// HM-11-A sends "AT+PIO21"
	// HM-11-B PIO2 goes HIGH and the LPC runs the uploaded program.

// HM-10 OR HM-11 COMMANDS
#define HM_RESET "AT+RESET"
#define HM_ISP_LOW "AT+PIO30"
#define HM_ISP_HIGH "AT+PIO31"
#define HM_LPC_RESET_LOW "AT+PIO20"
#define HM_LPC_RESET_HIGH "AT+PIO21"

// LPC Commands
#define LPC_CHECK "?"
#define Synchronized "Synchronized\n"

// FTDI
#define FT_ATTEMPTS 5

#define MAX_SIZE 32768
#define MAX_SIZE_16 2048

#define PRINT 1
#define NO_PRINT 0
#define PARSE 1
#define NO_PARSE 0


#define BLACK			0
#define BLUE			1
#define GREEN			2
#define CYAN			3
#define RED				4
#define MAGENTA			5
#define BROWN			6
#define LIGHTGRAY		7
#define DARKGRAY		8
#define LIGHTBLUE		9
#define LIGHTGREEN		10
#define LIGHTCYAN		11
#define LIGHTRED		12
#define LIGHTMAGENTA	13
#define YELLOW			14
#define WHITE			15


//Serial Port handle.
//Used by FTD2XX
FT_HANDLE handle = NULL;
FT_STATUS FT_status;
DWORD EventDWord;
DWORD TxBytes;
DWORD bytes;
DWORD RxBytes;
DWORD BytesReceived;
unsigned char RawRxBuffer[256];
unsigned char ParsedRxBuffer[256];

//File to be loaded.	
FILE *fileIn;
FILE *hexDataFile;
FILE *UUEDataFile;

//Reading characters from a file.
unsigned char charToPut;

//Total bytesRead.
int totalCharsRead = 0;

struct hexFile {
	//To hold file hex values.
	unsigned char fileData_Hex_String[MAX_SIZE];
	int fileData_Hex_String_Size; unsigned char fhexByteCount[MAX_SIZE_16];
	int hexFileLineCount;
	unsigned char fhexAddress1[MAX_SIZE_16];
	unsigned char fhexAddress2[MAX_SIZE_16];
	unsigned char fhexRecordType[MAX_SIZE_16];
	unsigned char fhexCheckSum[MAX_SIZE_16];

};

struct UUE_Data{
	unsigned char UUE_Encoded_String[MAX_SIZE];
	unsigned char b[3];
	unsigned char d[4];

	int paddedIndex;
	int UUE_Encoded_String_Index;
};



// States for FTDI state machine.
typedef enum {
    FTDI_SM_OPEN,
   	FTDI_SM_RESET,
    FTDI_SM_CLOSE,
    FTDI_SM_ERROR,
} FTDI_state;

// States for RX state machine.
typedef enum {
	RX_NODATA,
	RX_INCOMPLETE,
	RX_COMPLETE,
	RX_COMP_AND_INC_DATA,
	RX_ERROR,
} RX_state;

int fullAddress = 0;

///////////////////// PROGRAM ////////////////////////////
////////////////////// START /////////////////////////////

int main(int argc, char *argv[])
{


	clearConsole();
	
	startScreen();	
	// Stores hexFile data.
	struct hexFile hexFile;

	// Stores UUE data.
	struct UUE_Data UUE_Data;

	//For setting state of DTR/CTS.
	unsigned char DTR_Switch;
	unsigned char CTS_Switch;

	unsigned char rxString[256];

	// Stores file size.
	int fileSize;

	// Local for FTDI State Machine.
	//FTDI_state FTDI_Operation = RX_CLOSE;

	//If the user fails to give us two arguments yell at him.	
	if ( argc != 2 ) {
		fprintf ( stderr, "Usage: %s <readfile1>\n", argv[0] );
		exit ( EXIT_FAILURE );
	}

	//Open file using command-line info; for reading.
	fileIn = open_file (argv[1], "rb" );
	
	// Open FTDI.
	FTDI_State_Machine(FTDI_SM_OPEN, FT_ATTEMPTS);

	// Strange, this has to happen to get a response from the device.
	FTDI_State_Machine(FTDI_SM_RESET, FT_ATTEMPTS);	 
	
	//Set up pins we will use.
	//FT_SetBitMode(handle, PIN_DTR | PIN_CTS, 1);
	//Setup serial port, even though we are banging.
	FT_SetBaudRate(handle, 9600);  //* Actually 9600 * 16

	// Sizes file to be used in data handling.
	fileSize = fileSizer();

	//Convert file to one long char array.
	hexFile = hexFileToCharArray(fileSize);

	// Write hex string back to a file.  Used for debugging.
	writeHexDataTofile(hexFile.fileData_Hex_String, hexFile.fileData_Hex_String_Size, hexFile.fhexByteCount, hexFile.hexFileLineCount);
	
	// Convert hex data to UUE.
	UUE_Data = UUencode();

	writeUUEDataTofile(UUE_Data.UUE_Encoded_String, UUE_Data.UUE_Encoded_String_Index);
	
	// Let's wake the device chain (FTDI, HM-10, HM-10, LPC)

	printf("%s\n", UUE_Data.UUE_Encoded_String);
	
	wake_devices();
	
	check_HM_10();

	clearConsole();
	
	// Set LPC into ISP mode.
	set_ISP_mode(NO_PRINT);

	// Get LPC Device info.
	//get_LPC_Info(PRINT);

	//Sleep(500);
	//txString(HM_RESET, sizeof(HM_RESET), PRINT, 0);
	
	// Send Unlock Code
	txString("U 23130\n", sizeof("U 23130\n"), PRINT, 0);
	Sleep(500);
	rx(PARSE, PRINT);

	// Write memory
	txString("W 268435456 4\n", sizeof("W 268435456 4\n"), PRINT, 0);
	Sleep(500);
	rx(PARSE, PRINT);

	txString("$%`^H%P``\n", sizeof("$%`^H%P``\n"), PRINT, 0);
	rx(NO_PARSE, PRINT);
	txString("226\n", sizeof("226\n"), PRINT, 0);
	Sleep(120);
	rx(NO_PARSE, PRINT);

	
	/*
	// Read memory
	txString("R 268436224 4\n", sizeof("R 268436224 4\n"), PRINT, 0);
	Sleep(500);
	rx(PARSE, PRINT);
	txString("OK\n", sizeof("OK\n"), PRINT, 0);
	Sleep(500);
	rx(PARSE, PRINT);


		// Write memory
		txString("W 268436224 8\n", sizeof("W 268436224 8\n"), 0);
		Sleep(500);
		rx(NO000, rxString);

		txString("(5&AE(&-A<@\n403\n", sizeof("(5&AE(&-A<@\n403\n"), 0);
		
		// TEST
		// HEX: 54 68 65 20 63 61 72
		// DECL 84  104 101 32 99 97
		// UUE: 5&AE(&-A

		printf("THIS NUMBER: %i\n", "RESEND");

		Sleep(500);
		rx(NO000, rxString);

	// Read memory
	txString("R 268436224 4\n", sizeof("R 268436224 4\n"), 0);
	Sleep(500);
	rx(NO000, rxString);
	txString("OK\n", sizeof("OK\n"), 0);
	Sleep(500);
	rx(NO000, rxString);

	//txString("#0V%T\n", sizeof("#0V%T\n"), 0);
	//Sleep(500);
	//rx(NO000, rxString);
	*/

	//Close files.
	fclose ( fileIn );
	fclose ( UUEDataFile );
	fclose ( hexDataFile );

	clearConsole();
} // END PROGRAM


///////////// LPC Handling ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

unsigned char set_ISP_mode(int print)
{
	unsigned char rxString[256];

	int successful = 0;

	printf("Starting LPC ISP.");
	for (int i = 0; i < 3; ++i)
	{	
		txString(HM_ISP_LOW, sizeof(HM_ISP_LOW), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");

		txString(HM_LPC_RESET_LOW, sizeof(HM_LPC_RESET_LOW), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");
		
		txString(HM_LPC_RESET_HIGH, sizeof(HM_LPC_RESET_HIGH), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");

		txString(HM_ISP_HIGH, sizeof(HM_ISP_HIGH), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");
		
		// Synchronized check.
		txString(LPC_CHECK, sizeof(LPC_CHECK), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");

		// Tell the LPC we are synchronized.
		txString(Synchronized, sizeof(Synchronized), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");

		// Set crystal
		txString("12000\n", sizeof("12000\n"), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		printf(".");

		txString("A 0\n", sizeof("A 0\n"), print, 10);
		Sleep(500);
		rx(PARSE, print);		
		printf(".");

		// Set baud
		//txString("9600\n", sizeof("9600\n"), 0);
		//Sleep(500);
		//setTextGreen();
		//printf("%s\n", ParsedRxBuffer);

		Sleep(100);

		// 
		if (successful > 6)
		{
			OK();
			return 1;	
		}
		else
		{
			Failed();
			successful = 0;
			printf("Retrying.");
			clearBuffers();
			Sleep(500);
		}
	}
	return 0;
}

void wake_devices()
{
	txString("Wake", sizeof("Wake"), NO_PRINT, 10);
	Sleep(500);
	rx(NO_PARSE, PRINT);
	printf("Waking Devices...\n");
}

void check_HM_10()
{
	unsigned char char_RSSI[2];
	int int_RSSI;

	txString("AT+RSSI?", sizeof("AT+RSSI?"), NO_PRINT, 0);
	Sleep(500);

	FT_GetStatus(handle, &RxBytes, &TxBytes, &EventDWord);

	if (RxBytes > 0) {
		FT_status = FT_Read(handle,RawRxBuffer,RxBytes,&BytesReceived);
	}
	else
	{
		// Bad RSSI read.
	}		
	
	if(sizeof(RawRxBuffer) < 10)
	{
		char_RSSI[0] = 0;
		char_RSSI[1] = RawRxBuffer[8];
		char_RSSI[2] = RawRxBuffer[8];	
	}
	else if (sizeof(RawRxBuffer) > 9)
	{
		char_RSSI[0] = RawRxBuffer[8];
		char_RSSI[1] = RawRxBuffer[9];
		char_RSSI[2] = RawRxBuffer[10];	
	}
	
	//int_RSSI = atoi(char_RSSI);
	sscanf(char_RSSI, "%D", &int_RSSI);

	if (int_RSSI > 30 && int_RSSI < 60)
	{
		clearConsole();
		printf("HM-10 signal: ");
		setTextGreen();
		printf("Strong\n");		
	}
	else if (int_RSSI > 60 && int_RSSI < 90)
	{
		clearConsole();
		printf("HM-10 signal: ");
		printf("Medium\n");	
	}
	else if (int_RSSI > 90 && int_RSSI < 120)
	{
		clearConsole();
		printf("HM-10 signal: ");
		setTextRed();
		printf("Weak\n");		
	}
	clearConsole();
}


unsigned char get_LPC_Info(bool print)
{
	int successful = 0;
	unsigned char PartID[256];
	unsigned char UID[256];
	unsigned char BootVersion[256];

	for (int i = 0; i < 3; ++i)
	{	
		// Read Part ID
		txString("N\n", sizeof("N\n"), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		copy_string(PartID, ParsedRxBuffer);
		
		// Read UID
		txString("J\n", sizeof("J\n"), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		copy_string(UID, ParsedRxBuffer);

		// Boot Version
		txString("K\n", sizeof("K\n"), print, 0);
		Sleep(500);
		successful += rx(PARSE, print);
		copy_string(BootVersion, ParsedRxBuffer);
		

		clearConsole();

		if (successful > 2)
		{
			printf("Device info successfully read: \n\n");
			printf("Boot Version: %s\n", BootVersion);
			printf("UID:          %s\n", UID);
			printf("Part Number:  %s\n", PartID);
			break;	
		}
		else
		{
			successful = 0;
			printf("Attempt %i to get LPC info and failed. Retrying...%s\n", i);
			clearBuffers();
			Sleep(500);
		}
	}

}

void OK()
{
	setTextGreen();
	printf("OK.\n\n");
	clearConsole();
}
void Failed()
{
	setTextRed();
	printf("FAILED.\n\n");
	clearConsole();	
}

void copy_string(char *target, char *source)
{
   while(*source)
   {
      *target = *source;
      source++;
      target++;
   }
   *target = '\0';
}

///////////// FTDI  //////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

int FTDI_State_Machine(int state, int FT_Attempts)
{
	switch(state)
	{
		case FTDI_SM_OPEN: 
			// Loop for command attempts.
			for (int i = 0; i < FT_Attempts; ++i)
			{
				// FT command
				FT_Open(0, &handle);
				if (FT_status != FT_OK)
				{
					printf("Could not open FTDI device. Attempt %i\n", i);
					Sleep(100);
				}
				else
				{
					return 1;
				}
			}
		case FTDI_SM_RESET: 
			for (int i = 0; i < FT_Attempts; ++i)
			{
				FT_ResetPort(handle);
				if (FT_status != FT_OK)
				{
					printf("Could not reset FTDI device. Attempt %i\n", i);
					Sleep(100);
				}
				else
				{
					return 1;
				}
			}
		case FTDI_SM_CLOSE:
			for (int i = 0; i < FT_Attempts; ++i)
			{
				FT_Close(handle);
				if (FT_status != FT_OK)
				{
					printf("Could not close FTDI device. Attempt %i\n", i);
					Sleep(100);
				}
				else
				{
					return 1;
				}
			}
		case FTDI_SM_ERROR:
			printf("Error in FTDI SM call.");
			break;
	}
}

//Open file for reading, function.
static FILE *open_file ( char *file, char *mode )
{
  FILE *fileOpen = fopen ( file, mode );

  if ( fileOpen == NULL ) {
    perror ( "Unable to open file" );
    exit (EXIT_FAILURE);
  }

  return fileOpen;
}

int fileSizer()
{
	int fileSize;
	while((fgetc (fileIn)) != EOF)
	{
		fileSize++;
	}
	rewind(fileIn);
	return fileSize;
}


unsigned char rx(bool parse, bool printOrNot)
{	
	// 0 = unsuccessful, 1 = LPC, 2 = HM-10
	int device_and_success = 0;
	//FT_SetTimeouts(handle, timeout, 0);
	FT_GetStatus(handle, &RxBytes, &TxBytes, &EventDWord);

	setTextGreen();

	if (RxBytes > 0) {

		FT_status = FT_Read(handle,RawRxBuffer,RxBytes,&BytesReceived);
		if (FT_status == FT_OK) {

			if(parse)
			{
				device_and_success = parserx();
			}
			else
			{
				strcpy(ParsedRxBuffer, RawRxBuffer);
				device_and_success = 1;
			}

			clearConsole();
			
			if(printOrNot)
			{
				setTextGreen();
				printf("%s\n", ParsedRxBuffer);
				clearConsole();
				clearBuffers();
			}
	
			if(device_and_success > 0){return 1;}

		}
		else {
			printf("RX FAILED \n");
			clearConsole();
			return 0;
		}
	}
	clearConsole();
	return 0;
}


unsigned char parserx()
{
		// Parses data from LPC and HM-10.
		int successful = 0;
		
		// Does the RawRxBuffer contain an CR LF string?
		unsigned char *CR_LF_CHK = strstr(RawRxBuffer, "\r\n");
		unsigned char *LF_CHK = strstr(RawRxBuffer, "\n");

		// Clear ParsedRxBuffer.
		for (int i = 0; i != sizeof(ParsedRxBuffer); ++i)
		{
			ParsedRxBuffer[i] = 0;
		}

		// If it does contain CR LF
		if(CR_LF_CHK != '\0')
		{
			// Load the Raw RX into the Parsed Rx.
			strcpy(ParsedRxBuffer, RawRxBuffer);
			
			// If the LPC responds, we want to remove CR and LF.
			// Let's replace CR LF with "  ".
			int replaceIndex = 0;
			while(replaceIndex < sizeof(ParsedRxBuffer))
			{
				if(ParsedRxBuffer[replaceIndex] == '\r' && ParsedRxBuffer[replaceIndex+1] == '\n')
				{
					// REWRITE TO SHORTEN STRING, INSTEAD OF '0'
					ParsedRxBuffer[replaceIndex] = ' ';
					ParsedRxBuffer[replaceIndex+1] = ' ';
				}								
				replaceIndex++;
			}
			// About to reuse counter.
			replaceIndex=0;

			// We know we are talking to the LPC, let's remove echo crap.
			// Determine echo by "N/n0/r/n".  The "/n0" are fairly unique
			// we'll use them.
			if (ParsedRxBuffer[1] == '\n' && ParsedRxBuffer[2] == '0')
			{
				// Here, we are shortening the string due to echo.
				// "N/n0/r/n" = 5 characters.
				while(replaceIndex < sizeof(ParsedRxBuffer))
				{
					ParsedRxBuffer[replaceIndex] = ParsedRxBuffer[replaceIndex+6];
					replaceIndex++;
				}
				// Let's say this was a successful parsing.
				successful = 1;
			}
			// I NEED TO ADD COMMAND CODE RETURN PARSING.
			else if (ParsedRxBuffer[1] == '\n' && ParsedRxBuffer[2] == '1')
			{
				printf("LPC Command Failed\n");
				//LPC Responded, but erroneously.
				successful = 1;
			}
			successful = 1;
			
			if (ParsedRxBuffer[0] == 0)
			{
				while(replaceIndex < sizeof(ParsedRxBuffer))
				{
					ParsedRxBuffer[replaceIndex] = ParsedRxBuffer[replaceIndex+1];
					replaceIndex++;
				}
				printf("CMD_SUCCEDED");
			}

		}
		// Is it an HM-10?
		else if (RawRxBuffer[0] == 'O' && RawRxBuffer[1] == 'K' && RawRxBuffer[2] == '+')
		{
			strcpy(ParsedRxBuffer, RawRxBuffer);
			// HM-10 responded.
			successful=2;
		}
		// If the RawRxBuffer data does not contain "\r\n" or "OK+" strings.
		else
		{
			strcpy(ParsedRxBuffer, RawRxBuffer);
			successful=0;
		}

		// Clear RawRxBuffer
		for (int i = 0; i != sizeof(RawRxBuffer); ++i)
		{
			RawRxBuffer[i] = 0x00;
		}
		return successful;
}

void clearBuffers()
{
	// Clear ParsedRxBuffer.
	for (int i = 0; i != sizeof(ParsedRxBuffer); ++i)
	{
		ParsedRxBuffer[i] = 0;
	}

		// Clear RawRxBuffer
	for (int i = 0; i != sizeof(RawRxBuffer); ++i)
	{
		RawRxBuffer[i] = 0;
	}
}


char txString(char string[], int txString_size, bool printOrNot, int frequency_of_tx_char)
{
	unsigned char FTWrite_Check;
	
	for (int i = 0; i < (txString_size-1); i++){
		//This should print just data (ie, no Start Code, Byte Count, Address, Record type, or Checksum).
		FTWrite_Check = FT_Write(handle, &string[i], (DWORD)sizeof(string[i]), &bytes);
		Sleep(frequency_of_tx_char);
	}	

	// Let's check if the send string contains a newline character.
	unsigned char * newLineTest = strstr(string, "\n");
	// No? Let's add it.
	if(printOrNot){
		if (newLineTest == '\0')
		{
			setTextRed();
			printf("%s\n", string);
		}
		else{
			setTextRed();
			printf("%s", string);	
		}	
	}
}

///////////// Debugging //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

void writeUUEDataTofile(unsigned char UUE_Encoded_String[], int UUE_Encoded_String_Index)
{
	unsigned char UnixFilePermissions[] = "0777";

	UUEDataFile = open_file ("uueFile.uue", "w" );
	
	unsigned char UUELineCountCharacter;
	int test = 0;

	// 764 hex characters.
	// 1018.66666 UUE characters


	// Create UUE header 
	fprintf(UUEDataFile, "begin %s %s\n", UnixFilePermissions, "uueFile.uue");
	if (UUEDataFile == NULL) {
		printf("I couldn't open uueFile.uue for writing.\n");
		exit(0);
	}
	else
	{
		// Loop for total characters.
		for (int characterIndex = 0; characterIndex < UUE_Encoded_String_Index; characterIndex)
		{			
			if (test == 0)
			{
				// Add line count character at beginning of line.
				fprintf(UUEDataFile, "M");		
			}
			else
			{
				// Add line count character at beginning of line.
				UUELineCountCharacter = characterIndex/test;
				UUELineCountCharacter = (UUELineCountCharacter + ' ');
				fprintf(UUEDataFile, "%c", UUELineCountCharacter);		
			}
		
			// Loop for characters per line.			
			for (int lineIndex = 0; lineIndex < 45; ++lineIndex)
			{
				if (UUE_Encoded_String[characterIndex] == ' ')
				{
					fprintf(UUEDataFile, "'");
					characterIndex++;
				}
				else
				{
					fprintf(UUEDataFile, "%c", UUE_Encoded_String[characterIndex]);	
					characterIndex++;
				}
			}
			test++;
			fprintf(UUEDataFile, "\n");
			
			//printf("\n\n\n%i", UUE_Encoded_String_Index);
		}
		fprintf(UUEDataFile, "'\n");	
		fprintf(UUEDataFile, "end\n");	
	}
}

void writeHexDataTofile(unsigned char fileData_Hex_String[], int hexDataCharCount, unsigned char byteCount[], int hexFileLineCount)
{
	
	hexDataFile = open_file ("hexFile.hex", "w" );
	if (hexDataFile == NULL) {
		printf("I couldn't open hexFile.hex for writing.\n");
		exit(0);
	}
	
	for (int totalDataIndex = 0; totalDataIndex < hexDataCharCount; totalDataIndex)
	{
		for (int lineIndex = 0; lineIndex < hexFileLineCount; ++lineIndex)
		{
			int bytesThisLine = (byteCount[lineIndex]);
			for (int i = 0; i < bytesThisLine && totalDataIndex < hexDataCharCount; ++i)  //need to change 16 to byteCount.
			{
				if ((fileData_Hex_String[totalDataIndex]) != 0x00)
				{
					fprintf(hexDataFile, "%02X", fileData_Hex_String[totalDataIndex]);
				}
				else
				{
					fprintf(hexDataFile, "00", fileData_Hex_String[totalDataIndex]);
				}
				totalDataIndex++;
			}
		fprintf(hexDataFile, "\n");
		}

	}
}


////////////////////////////// Data Handling (Conversion, etc.) //////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

//Copied in from lpc21isp.c
static unsigned char Ascii2Hex(unsigned char c)
{
	if (c >= '0' && c <= '9')
	{
		return (unsigned char)(c - '0');
	}
	if (c >= 'A' && c <= 'F')
	{
		return (unsigned char)(c - 'A' + 10);
	}
	if (c >= 'a' && c <= 'f')
	{
        return (unsigned char)(c - 'A' + 10);
	}
	//printf("\n !!! Bad Character: 0x%2x in file at totalCharsRead=%d !!!\n\n", c, totalCharsRead);
	return 0;  // this "return" will never be reached, but some compilers give a warning if it is not present
} 

int Hex2Int(unsigned char c)
{
	int first = c / 16 - 3;
	int second = c % 16;
	int result = first*10 + second;
	//if(result > 9) result--;
	return result;
}

int Hex2Ascii(unsigned char hexValue)
{
	unsigned char c = hexValue >>= 4;
	hexValue <<= 4;
	unsigned char d = hexValue >>= 4;

	int high = Hex2Int(c) * 16;
	int low = Hex2Int(d);
	return high+low;
}

void clearSpecChar()
{
	//Removes CR, LF, ':'  --Bdk6's
	while (charToPut == '\n' || charToPut == '\r' || charToPut ==':'){
		(charToPut = fgetc (fileIn));
		totalCharsRead++;
	}
}

int readByte(){
	//Holds combined nibbles.
	unsigned char hexValue;
	
	//Get first nibble.
	charToPut = fgetc (fileIn);
	clearSpecChar();
	//Put first nibble in.
	hexValue = (Ascii2Hex(charToPut));
	//Slide the nibble.
	hexValue <<= 4;
	//Put second nibble in.
	charToPut = fgetc (fileIn);
	clearSpecChar();
	//Put the nibbles together.
	hexValue |= (Ascii2Hex(charToPut));
	//Return the byte.
	totalCharsRead=totalCharsRead+2;
	return hexValue;
}


//Convert file to one long char array.
struct hexFile hexFileToCharArray(int fileSize)
{
	struct hexFile hexFile;

	//To count through all characters in the file.
	int i = 0;
	int hexDataIndex = 0;

	//Holds line count.	
	int charsThisLine;

	//Loop through each character until EOF.
	while(totalCharsRead  < fileSize){
		
		//BYTE COUNT
		hexFile.fhexByteCount[i] = readByte();
		
		//ADDRESS1 //Will create an 8 bit shift. --Bdk6's
		hexFile.fhexAddress1[i] = readByte();
		
		//ADDRESS2
		hexFile.fhexAddress2[i] = readByte();
		
		//RECORD TYPE
		hexFile.fhexRecordType[i] = readByte();	

		if (hexFile.fhexRecordType[i] == 0)
		{
			fullAddress = hexFile.fhexAddress1[i];
			fullAddress <<= 8;
			fullAddress |= hexFile.fhexAddress2[i];
			fullAddress =  fullAddress/16;
		}
		
		//Throws the byte count (data bytes in this line) into an integer.
		charsThisLine = hexFile.fhexByteCount[i];

		//////// DATA ///////////////////
		// We only want data.
		if (hexFile.fhexRecordType[i] == 0)
		{
			while (hexDataIndex != charsThisLine && totalCharsRead  < fileSize && charsThisLine != 0x00)
			{
				//Store the completed hex value in the char array.
				hexFile.fileData_Hex_String[hexFile.fileData_Hex_String_Size] = readByte();
				
				//Index for data.
				hexFile.fileData_Hex_String_Size++;
				//Index for loop.
				hexDataIndex++;
			}
		//Reset loop index.
		hexDataIndex=0;
		}

		
		//////// CHECK SUM //////////////
		if (charToPut != 0xFF){
			hexFile.fhexCheckSum[i] = readByte();
		}

		hexFile.hexFileLineCount++;
		i++;
	}
	return hexFile;
}

struct UUE_Data UUencode()
{
	// ASCII->HEX->UUE Test Strings
	// ASCII: The witch Lilith knows my soul.
	// HEX: {0x54, 0x68, 0x65, 0x20, 0x77, 0x69, 0x74, 0x63, 0x68, 0x20, 0x4c, 0x69, 0x6c, 0x69, 0x74 0x68, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x20, 0x6d, 0x79, 0x20, 0x73, 0x6f, 0x75, 0x6c, 0x2e};
	// UUE-ASCII: ?5&AE('=I=&-H($QI;&ET:"!K;F]W<R!M>2!S;W5L+@
	// UUE-HEX:{35 26 41 45 28 27 3d 49 3d 26 2d 48 28 24 51 49 3b 26 45 54 3a 22 21 4b 3b 46 5d 57 3c 52 21 4d 3e 32 21 53 3b 57 35 4c 2b 40}
	//unsigned char testUUE_HEX[] = {0x54, 0x68, 0x65, 0x20, 0x63, 0x61, 0x72, 0x00};

	// Stores hexFile data.
	struct hexFile hexFile;

	struct UUE_Data UUE_Data;
	//unsigned char fileData_Hex_String[], int hexDataCharCount


	for(int hexDataIndex = 0;  hexDataIndex < hexFile.fileData_Hex_String_Size; hexDataIndex)
	{
		// Load chars or nulls
		for (int i = 0; i < 3; i++)
		{

			if (hexDataIndex < hexFile.fileData_Hex_String_Size)
			{
				UUE_Data.b[i] = hexFile.fileData_Hex_String[hexDataIndex];	
			}
			else
			{
				UUE_Data.b[i] = 0;
				UUE_Data.paddedIndex++;
			}
			hexDataIndex++;
		}
		
		// UUEncode
		UUE_Data.d[0] = (((UUE_Data.b[0] >> 2) & 0x3f) + ' ');
		UUE_Data.d[1] = ((((UUE_Data.b[0] << 4) | ((UUE_Data.b[1] >> 4) & 0x0f)) & 0x3f) + ' ');
		UUE_Data.d[2] = ((((UUE_Data.b[1] << 2) | ((UUE_Data.b[2] >> 6) & 0x03)) & 0x3f) + ' ');
		UUE_Data.d[3] = ((UUE_Data.b[2] & 0x3f) + ' ');
		


		if (UUE_Data.b[0] == 0x00)
		{
			UUE_Data.b[0] = 0x60;
		}	
		if (UUE_Data.b[1] == 0x00)
		{
			UUE_Data.b[1] = 0x60;
		}	
		if (UUE_Data.b[2] == 0x00)
		{
			UUE_Data.b[2] = 0x60;
		}	

		
		// Put the UUEncoded chars into their own string.
		for (int i = 0; i < 4; i++)
		{
			UUE_Data.UUE_Encoded_String[UUE_Data.UUE_Encoded_String_Index] = UUE_Data.d[i];
			UUE_Data.UUE_Encoded_String_Index++;
		}
	}

	// ADD FOR-LOOP TO DIVIDE UUE DATA INTO 61 CHAR STRINGS.

	/*
	for (int i = 0; i < (UUE_Encoded_String_Index-paddedIndex); ++i)
	{
		printf(" 0x%2x \n", UUE_Encoded_String[i]);
	}
	*/
	UUE_Data.UUE_Encoded_String_Index = UUE_Data.UUE_Encoded_String_Index - UUE_Data.paddedIndex;
	return UUE_Data;
}

void setTextRed()
{
	setColor(LIGHTRED, BLACK);
}
void setTextGreen()
{
	setColor(LIGHTGREEN, BLACK);
}

void setColor(int ForgC, int BackC)
{
     WORD wColor = ((BackC & 0x0F) << 4) + (ForgC & 0x0F);
     SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), wColor);
     return;
}

void clearConsole()
{
	setColor(WHITE, BLACK);
}

void startScreen()
{
	printf("\n");
	printf("\n");
	printf("**************************************************************************\n");
	printf("**** Mutant LPC1114 Downloader v.1                                   *****\n");
	printf("**** Hacked Out with Little Thought                                  *****\n");
	printf("****                                   Thanks to Bdk6                *****\n");
	printf("****                            His help was more than invaluable,   *****\n");
	printf("****                                 it was a necessity.             *****\n");
	printf("**************************************************************************\n");
	printf("\n");
	printf("\n");
	clearConsole();
}